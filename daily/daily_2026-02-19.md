# 2026-02-19

## ■ Stats
- **Day Mode**: OFF（学習日）
- **Budget**: 360 min
- **Total Min**: 672 min
- **純粋な学習時間**: 513 min
- **休憩時間**: 159 min
- **運動時間**: 0 min
- **Avg Deep Score**: 3.72
- **Top1**: gem Deviseリサーチ、エンティティmとER図を定義。rails newの実行
- **Done条件**: 午後までに rails new をスタートして、GitHubにpushされている状態
- **切れたら→**: 技術選定リスト（Markdown）の成果物化

---

## ■ Top1 / Done条件 達成度フィードバック

**[定量面]**
- Top1構成3タスクのうち、DeviseリサーチはSessionsで31 min（07:51-08:22、DS=4.3）、エンティティ・テーブル・ER図の設計は64+36+72+27=199 min（08:23-12:09）を使用
- rails new + GitHub pushはmini_app_devセッション2件（14:34-16:37の123 min + 17:18-18:02の44 min = 167 min）で完了
- GitHub pushの完了は18:02 → Done条件「午後まで」に対して夕方扱いで若干超過
- 朝の計画（12:00タイムボックス）に対して：rails new開始は14:34と約2.5時間遅延

**[定性面]**
- DeviseリサーチはREADmeのみで「オーバースペック」と即断（DS=4.3）し、計画通り深追いを回避できた
- 設計フェーズ（エンティティ→リレーション→テーブル→ER図）は計画の「正しい順序」を守れており、2/17の反省が活かされた
- rails newはDockerfileとcompose.ymlを比較学習しながら進めたため167 minを要したが、「設計意図を考えながら」学習できた（生データWorkedと一致）
- 「12:00になったら強制打ち切りでrails newへ移行」のIf-Thenルールは今日も活用されなかった。ER図完了後に昼休憩に入り、実害は最小化されたが、設計完璧主義による先送りパターンは2/17から継続中

> **朝の計画視点**: Done条件を「12:00 までに rails new 完了」から「午後まで」に緩和していたが、実際の結果（push 18:02）を見ると、12:00タイムボックスを守れていれば午後に余裕が生まれていた。2/17設計241min超過→Done条件未達のパターンを再発させない設計が今後も必要。

---

## ■ 時間配分フィードバック

**[定量面]**
- Budget: 360 min → 実際の学習時間: 513 min（Budget達成率: 142.5%）
- 午前ブロック（07:26-12:09）：学習 253 min + 休憩 25 min（コーヒー）
- 午後ブロック（12:10-17:17）：学習 166 min + 休憩 134 min（昼食94 min + 散歩40 min）
- 夜間ブロック（17:18-20:45）：学習 94 min + 休憩 0 min
- 非学習時間の内訳：昼食+Netflix 94 min、散歩 40 min、合計 159 min（全体の23.7%）

**[定性面]**
- 午前ブロックは253 minの連続学習でDS平均4.2と高品質。7:26スタートの早い立ち上がりと明確なDone条件が奏功
- 昼休憩（94 min）後の再開ラグは6分のみ。朝の計画「昼食後は即再開・スピード意識」が自然に実行された
- 夜間は認知疲弊が顕著（Headroom=2）。knowledge_organization（まとめ試みたが断念、Friction=5）はこのタイミング配置の問題
- 513 minの学習量は良質だが、バーンアウト兆候が記録されており翌日（2/20 Shift）への回復リソース確保が懸念される

> **朝の計画視点**: Budget 360 minを513 min（+153 min）と超過。計画「午後は集中低下時の切れたら→実行」に対し、実際はrails new（DS=3.7、Focus=5）のFlowが続いた。「Flow状態で切り替えたくない → 切り替えない」のIf-Thenルールを正しく活用できた例。一方、夜間の「整理・振り返りのみ」設計は機能したが、knowledge_organizationの失敗は「夜間に新概念の定着・深い思考は行わない」ルールをまとめ作業にも適用すべき示唆を残した。

---

## ■ Worked

**1. 明確なDone条件による午前ブロックの学習維持**
- **Fact**: 7:26から12:09まで5セッション計253 minを、休憩1回（25 min）を挟んで継続学習。午前セッションDS平均4.2（planning 4.0 / Devise 4.3 / tag設計 4.3 / UX選定 4.3 / テーブル設計 4.0 / ER図 4.3）。
- **Why**: 「rails newをGitHubにpush」という単一の具体的成果物がDone条件として朝に設定されていたため、設計フェーズ全体を通して「何のために作業しているか」が明確だった。生データに「rails newをしてGithubにプッシュするという朝の明確な目標設定で夕方も安定して学習できていた」と記録あり。

**2. UX起点によるオーバースペック排除の即断**
- **Fact**: Devise（31 min）・tag設計（64 min）・UX検索選定（36 min）の3セッション計131 minで、Devise・acts-as-taggable-on・pg_search・action_tagを全て「現段階不要」と判断。DeviseはREADmeのみで通過（DS=4.3）。
- **Why**: 「ミニアプリの目的は検索体験の検証」というコンテキストを軸に選定したことで、UXを明確にすることが「何を入れなくていいか」の基準となった。セッションnoteに「uxを明確にすることで簡易的な実装で良いと気づけた」と記録。

**3. 昼食後の即座再開**
- **Fact**: 昼休憩（12:10-13:44、94 min）終了から13:50の読書セッション開始まで6分のラグのみ。
- **Why**: 朝の計画で「昼食後は即再開・スピード意識」をIf-Thenとして設定していたため、再開の意思決定コストがゼロだった。2/17で機能した行動パターンを計画に明示することで、本日も自動的に実行された。

---

## ■ Slipped

**1. 12:00タイムボックスの未活用によるrails new遅延**
- **Fact**: 朝の計画「12:00になったら強制打ち切りでrails newへ移行」に対し、実際のrails new開始は14:34（約2.5時間遅延）。ER図セッションが11:42-12:09まで延長し、その後94 minの昼休憩を挟んで午後移行。
- **Why**: 「ER図まで仕上げてからrails newに入りたい」という完了指向バイアスが12:00ルールをオーバーライドした。結果としてpush完了は18:02となり、Done条件の「午後まで」を超過。2/17から引き継がれているパターン（設計完璧主義 → Done条件到達不能）の再発。

**2. 技術選定リスト成果物化の未達（切れたら→未消化）**
- **Fact**: 朝の計画「切れたら→: 技術選定リスト（Markdown）の成果物化」に対応するセッションなし。knowledge_organization（16 min、19:55-20:11）でDockerと技術選定のまとめを試みたが断念。Headroom=2、Friction=5。
- **Why**: 「切れたら→」実行に適した「集中低下時の午後帯」ではなく、認知リソース枯渇後の夜間にアウトプット型作業を試行した。まとめフェーズを夜間に配置している構造的問題が再度顕在化。

**3. rails new実行時間の見積もり乖離**
- **Fact**: 朝の計画「rails new + push: 20-30 min」に対し、実際は123+44=167 min（計画の約5-6倍）。
- **Why**: Docker環境構築でアーカイブのDockerfileと校長のDockerfileを比較学習しながら進めたため有益だった一方、計画見積もりに「理解しながら進むコスト」が含まれていなかった。

---

## ■ Insights

**1. 技術選定の見積もりが構造的に甘い**
- **Fact**: 今日の設計フェーズ（Devise+tag+UX+テーブル+ER図）は計253 min。計画では各タスク30-40 minで合計130-155 min想定。2/17でも設計で241 minを使っており、2日連続で設計コストが見積もりの約1.5-2倍に達している。
- **Why**: 「技術選定 = ライブラリを1つ調査」として捉えているが、実際は「UX設計 → データモデル影響 → ライブラリ適合性 → 代替案比較」という連鎖が常に発生する。この連鎖コストを見積もりに組み込む必要がある。

**2. まとめフェーズの構造的機能不全**
- **Fact**: knowledge_organization（16 min）でDockerと技術選定のまとめに失敗（Friction=5、Headroom=2）。生データに「最近またまとめフェーズがうまく機能していないように感じる」と記録。
- **Why**: まとめ作業は認知リソース要求の高い「言語化・構造化」タスクであるにもかかわらず、常に夜間（Headroom最低帯）に配置されている。午前か昼直後のHeadroom高い帯への移動を検討すべき。

---

## ■ 今日の学習記録

**今日やったこと**
- **認証機能の技術選定**: DeviseとbcryptのGem比較を実施。ミニアプリの目的が「記事検索体験の検証」であること、開発スピード優先の判断基準から、bcrypt（カリキュラム習得済み）を選択。DeviseはREADmeのみで「カリキュラム外の機能（メール認証等）を含むためオーバースペック」と判断し深追いを回避。

- **学習Tips掲示板のUX設計と検索機能の技術選定**: 現在のミニ段階の探索方法を「カテゴリ分け × リスト型」で設計から、以下のライブラリを現段階ではオーバースペックと判断し不採用。ransackとLLMを使った検索体験の構築・検証を優先する方針を確定。
    - acts-as-taggable-on
    - pg_search
    - action_tag

- **テーブル設計の見直しとER図作成**: UI/UXの設計要件からタグ管理が必要と判断し、2/17のDB設計を再検討。tagも正規化が必要（中間テーブル構成）と気づき設計を修正。エンティティ定義とリレーションをテキストで書き起こし、mermaidでER図を自動生成。

- **Docker環境でのrails new実行**: アーカイブ動画のDockerfileと校長のミニアプリ開発時のDockerfileを比較しながら環境構築を学習。「単なるコマンド実行」ではなく「設計意図を考えながら学習する」学習アプローチで、database.yml設定・docker compose起動を完了してGitHubへpushすることができた

- **技術書の読書**: 「オブジェクト指向でなぜ作るのか」のポリモーフィズム章を読了。サブルーチン・共通サブルーチンという概念を学んだが、これまで学んだRailsカリキュラムの概念と実際のRailsアプリ開発とを結びつけるのに苦戦している

- **学習まとめの試行と断念**: Dockerと技術選定のknowledge_organizationを試みたが言語化できず断念。daily_reviewのみ実施。

**何を学んだか**
- **認証設計**：Deviseはオーバースペックと判断し、bcrypt（カリキュラム習得済み）で認証を実装する方針確定
- **検索設計**：ransackおよびLLMを使った検索体験を優先。acts-as-taggable-on・pg_search・action_tagは現段階で不採用
- **Docker**：Dockerfileのイメージ選択（FROM）・ポート設定・compose.ymlのvolumes/environment の設計意図を比較学習で理解
- **ポリモーフィズム**：「呼び出す側」と「呼び出される側」の分離という概念を読んだが、実際のRailsコードとの対応付けはまだできていない

---

## ■ Study Strategy for Next Day
2/20はシフトなので目標設定の方向性を成果ではなく時間ベースもしくは最小で設定する

---

## ■ Technical Learnings

**1. 認証設計: Devise vs bcrypt の選択**
- **Question**: ミニアプリの認証機能にDeviseとbcryptのどちらを使うべきか？
- **Answer**: bcryptを採用。Deviseはカリキュラム以上の機能（メール認証・OAuthなど）を含みオーバースペック。ミニアプリの目的は「記事検索体験の検証」であり、開発スピード優先でカリキュラム習得済みのbcryptを選択。
- **Conclusion**: Deviseのゴールは「本番アプリでの技術選定」として温存。

**2. 検索機能設計: ライブラリ選定**
- **Question**: 学習Tips掲示板の検索UXを実現するためのライブラリ選定
- **Answer**: ransackとLLMを使った検索体験を優先。現段階の探索方法は「カテゴリ分け × リスト型」に制限。acts-as-taggable-on（タグ管理専用でオーバースペック）、pg_search（Full-text searchで現段階不要）はいずれも不採用。
- **Conclusion**: ミニ段階の検証に不要な機能は採用しない。ransackによるシンプル検索で体験を先に作り、LLM検索は後段で検証。

**3. オブジェクト指向: ポリモーフィズム**
- **Question**: ポリモーフィズムとは何か。Railsアプリ開発ではどこに現れるか
- **Answer**: 「呼び出す側」が「呼び出される側」の具体的な実装を知らなくても動作する仕組み。サブルーチン=関数/メソッド、共通サブルーチン=クラスで定義されたメソッド。現在のRailsアプリとの対応付けは未解決のまま。
- **Evidence**: 「オブジェクト指向でなぜ作るのか」 該当章（ポリモーフィズム）
